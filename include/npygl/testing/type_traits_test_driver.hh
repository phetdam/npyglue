/**
 * @file testing/type_tratis_test_driver.hh
 * @author Derek Huang
 * @brief C++ header for the type_traits_test.cc test driver type
 * @copyright MIT License
 */

#ifndef NPYGL_TESTING_TYPE_TRAITS_TEST_DRIVER_HH_
#define NPYGL_TESTING_TYPE_TRAITS_TEST_DRIVER_HH_

#include <cstddef>  // for std::byte
#include <cstdint>
#include <map>
// GCC requires <memory_resource> for std::pmr::allocator to be complete
#include <memory_resource>
#include <string>
#include <tuple>
#include <type_traits>
#include <utility>
#include <vector>

#include "npygl/testing/ostream.hh"
#include "npygl/testing/traits_checker.hh"
#include "npygl/type_traits.hh"

namespace npygl {
namespace testing {

/**
 * Type alias for the `type_traits_test.cc` test driver type.
 *
 * This contains all the `traits_checker<Traits, Ts...>` specializations used
 * to evaluate the traits types and then provide the main driver type.
 * Originally, this type was used to test the `type_traits.hh` type traits, and
 * it will continue to serve in that capacity as more type traits are added.
 *
 * Given this, one may wonder why this type deserves its own header, and to
 * explain why, we must recount some history. In the past, as this driver type
 * grew longer and longer due to more traits types being added via
 * `traits_checker<Traits, Ts...>`, I realized that the mangled symbol
 * generated by the compiler would likely look quite ridiculous given how long
 * this type had become. After verifying my thoughts by running nm on the
 * type_traits_test program, I decided that I wanted to see a printout of the
 * full string name for this type. Since I already had `npygl::type_name`
 * implemented in `demangle.hh`, which uses `abi::__cxa_demangle` for compilers
 * that follow the Itanium ABI (e.g. GCC, Clang), I added the following to the
 * `main()` function of the `type_traits_test.cc` test program:
 *
 * @code{.cc}
 *   std::cout << npygl:type_name(typeid(driver_type)) << std::endl;
 * @endcode
 *
 * To my dismay, however, upon running `type_traits_test` after recompilation,
 * the program was instead printing the mangled type name. Originally, I
 * thought that maybe the GCC 11.3.0 `abi::__cxa_demangle` itself had some bug,
 * as `npygl::type_name` is a thin wrapper over it when compiling with Itanium
 * ABI compilers (MSVC provides a non-mangled type name in `std::type_info`).
 *
 * @note It appears that as of GCC 12.1, on 2025-03-22, this limitation with
 *  `abi::__cxa_demangle` still has not been fixed.
 *
 * Therefore, I tried using both nm -C and c++filt, but neither was able to
 * properly print the demangled name of this type, as they are likely using
 * `abi::__cxa_demangle` or a similar implementation internally. From some
 * experimentation with this type, after adding/removing some input types, it
 * appeared that if a mangled type name approached the 1024 character mark,
 * nm, c++filt, and `abi::__cxa_demangle` would all fail to demangle.
 *
 * As an alternative, I searched the Internet for solutions, and eventually
 * read somewhere that the LLVM project's `llvm::itaniumDemangle` function
 * could be a replacement for `abi::__cxa_demangle`. After tweaking my CMake
 * configuration appropriatly and installing LLVM libraries with apt, I tried
 * using `llvm::itaniumDemangle`, and was very happy to see it work properly.
 * However, since using `llvm::itaniumDemangle` would require that a user have
 * the `LLVMDemangle` library installed, I decided to keep using the built-in
 * `abi::__cxa_demangle` natively for `npygl::type_name`, with opt-in for using
 * `llvm::itaniumDemangle` if compiling with `-DNPYGL_USE_LLVM_DEMANGLE`.
 *
 * To smoke test this new functionality, I used `NPYGL_USE_LLVM_DEMANGLE` to
 * control conditional compilation of `type_traits_test.cc`. If defined,
 * instead of being compiled as the `type_traits.hh` test program,
 * `type_traits_test.cc` would be compiled into `llvm_demangle_test`, which
 * would call `npygl::type_name` on this very long test driver type, using the
 * LLVM demangling function as its underlying implementation.
 *
 * Now, the story should have ended there. I started working on npyglue less
 * and less, as I had already achieved the project's main goal, which was to
 * create NumPy arrays with essentially zero copying from appropriate C++
 * objects such as `std::Vector<T>`, Eigen matrix types, and LibTorch tensors.
 * My last commit to this repo was in January 2025, but here I am in March 2025
 * recounting this story because of a recent interest I developed in being able
 * to acquire the demangled string name of a type at *compile-time* instead of
 * relying on `typeid(T).name()` and an a runtime demangling solution. Although
 * the CTTI library (https://github.com/Manu343726/ctti/) exists for that
 * purpose, I wanted to see if I could implement a single function to get the
 * compile-time string name for a type using C++17, with the following usage:
 *
 * @code{.cc}
 *   constexpr auto my_type_name = npygl::type_name<T>();
 * @endcode
 *
 * Since I was only interested in supporting GCC, MSVC, and Clang, I already
 * knew that my starting point would be parsing MSVC's `__FUNCSIG__` and GCC +
 * Clang's `__PRETTY_FUNCTION__` compiler-provided string literals. In
 * particular, because I only needed to support C++17 and above, I figured
 * using a `constexpr` function would be enough. So after a day or two of some
 * fiddling in my spare time and using Godbolt to test with Clang, I succeeded
 * in creating `npygl::type_name<T>`, a `constexpr` function template that can
 * return a `std::string_view` of the `T` type name, in `ctti.hh`.
 *
 * However, ideally I would want to have some kind of test for this function.
 * As I began brainstorming a nice test setup for `npygl::type_name<T>`, it
 * occurred to me that maybe I should feed this `traits_checker_driver<Ts...>`
 * type that had defeated `abi::__cxa_demangle`, nm, and c++filt, to
 * `npygl::type_name<T>` as some kind of soak test, to see if it would work
 * correctly with possibly the most complex type I've ever seen in my life.
 * Originally, I added another macro to control conditional compilation of
 * `type_traits_test.cc` again, but now that there are 3 different usages for
 * the same type, I decided it was finally time to give this type its own
 * header and to instead include it into 3 different source files.
 *
 * Sadly, `npygl::type_name<T>` did not work properly on the first try with
 * this type when using MSVC or Clang due to errors in implementation. However,
 * after a bit of tweaking, it now works properly with all 3 compilers.
 */
using type_traits_test_driver = traits_checker_driver<
  // is_pair
  traits_checker<
    is_pair,
    std::tuple<
      std::pair<int, int>,
      std::pair<double, double>,
      std::pair<std::pair<double, int>, std::true_type>,
      std::pair<double, std::false_type>,
      std::pair<std::pmr::vector<double>, std::false_type>
    >
  >,
  // is_tuple
  traits_checker<
    is_tuple,
    std::tuple<
      std::tuple<int, double, int>,
      std::tuple<double, std::string, double>,
      std::pair<std::pair<double, int>, std::false_type>,
      std::pair<std::tuple<std::tuple<unsigned, char>, int>, std::true_type>,
      std::pair<std::map<std::string, std::vector<double>>, std::false_type>
    >
  >,
  // always_true
  traits_checker<
    always_true,
    std::tuple<
      double,
      std::string,
      unsigned,
      char,
      std::map<unsigned, int>,
      // test skipped<>
      skipped<double>,
      skipped<std::pair<std::pair<int, char>, std::false_type>>,
      skipped<std::pair<double, std::false_type>>
    >
  >,
  // has_type_member
  // note: also indirectly tests same_type + type_filter
  traits_checker<
    has_type_member,
    std::tuple<
      std::pair<same_type<int, double, unsigned>, std::false_type>,
      std::enable_if<true>,
      std::pair<std::enable_if<false>, std::false_type>,
      std::pair<std::tuple<std::pair<int, int>, std::string>, std::false_type>,
      std::remove_pointer<const char*>,
      same_type<char, char, char, char, char, char>,
      std::add_pointer<std::string>,
      same_type<
        type_filter_t<
          has_type_member,
          int,
          std::enable_if<true>,
          std::remove_reference<const std::vector<unsigned>&>,
          double,
          std::string
        >,
        std::tuple<
          std::enable_if<true>,
          std::remove_reference<const std::vector<unsigned>&>
        >
      >,
      same_type<
        type_filter_t<always_true, double, int, unsigned, char>,
        std::tuple<double, int, unsigned, char>
      >
    >
  >,
  // test partially_fixed base specialization
  traits_checker<
    partially_fixed<is_same_type, char, char, char, char>::type,
    std::tuple<char, std::pair<int, std::false_type>>
  >,
  // test partially_fixed with fix_first_types
  traits_checker<
    partially_fixed<is_same_type, fix_first_types, int>::
      type,
    std::tuple<std::pair<int, std::true_type>, std::pair<double, std::false_type>>
  >,
  // test partially_fixed with fix_last_types
  traits_checker<
    partially_fixed<is_same_type, fix_last_types, int>::
      type,
    std::tuple<int, std::pair<std::string, std::false_type>>
  >,
  // is_monomorphic_tuple
  // note: also tests monomorphic_tuple_type, type_filter, has_type_member
  traits_checker<
    is_monomorphic_tuple,
    std::tuple<
      std::tuple<int, int>,
      std::pair<std::tuple<double, int, double>, std::false_type>,
      std::pair<std::tuple<std::string, std::string>, std::true_type>,
      std::tuple<unsigned, unsigned, unsigned, unsigned>,
      std::pair<
        std::tuple<std::string, std::string, int, std::string, std::string>,
        std::false_type
      >,
      std::tuple<std::vector<unsigned>, std::vector<unsigned>>,
      std::tuple<void*, void*, void*, void*>,
      std::pair<std::tuple<std::map<unsigned, int>, char>, std::false_type>,
      std::tuple<
        type_filter_t<always_true, int, double, int, unsigned>,
        std::tuple<int, double, int, unsigned>
      >,
      std::tuple<
        type_filter_t<
          always_true,
          std::enable_if<true>,
          std::decay<const volatile void*>
        >,
        std::tuple<std::enable_if<true>, std::decay<const volatile void*>>,
        type_filter_t<
          has_type_member,
          std::enable_if<true>,
          std::decay<const volatile void*>,
          std::enable_if<false>,
          std::enable_if<false>
        >
      >,
      std::pair<std::tuple<unsigned, int>, std::false_type>
    >
  >,
  // has_static_size
  traits_checker<
    has_static_size,
    std::tuple<
      std::tuple<int, double, char>,
      std::pair<std::vector<double>, std::false_type>,
      std::pair<std::tuple<char, unsigned, std::string>, std::true_type>,
      std::pair<double, const volatile void*>,
      std::array<unsigned, 100>,
      char[256],
      std::pair<std::string, std::false_type>,
      std::pair<std::map<std::string, unsigned>, std::false_type>,
      int[2][3][4],
      // FIXME: cannot have flexible array members in a struct. we should have
      // some sort of abstract pair- or tuple-like pack type whose sole purpose
      // is to store types, e.g. has sizeof == 1, to avoid this issue.
      std::pair<double[], std::false_type>
    >
  >,
  // static_size (indirectly tests static_size_traits)
  traits_checker<
    static_size,
    std::tuple<
      std::pair<
        std::vector<double>,
        traits_value_is_not_equal<unsigned, 2u>
      >,
      std::pair<
        std::pmr::vector<unsigned>,
        traits_value_is_equal<unsigned, 1u>
      >,
      std::pair<
        const double[256],
        traits_value_is_equal<unsigned, 256u>
      >,
      std::pair<
        std::array<int, 32>,
        traits_value_is_equal<unsigned, 32u>
      >,
      // some silly comparisons
      std::pair<
        std::array<int, 64>,
        traits_value_is_greater<unsigned, 24>
      >,
      std::pair<
        unsigned[1024],
        traits_value_is_less_equal<unsigned long, 2048>
      >,
      // multidimensional fixed-size array
      std::pair<
        double[24][32][46],
        traits_value_is_equal<unsigned, 24>
      >,
      // skip testing for traits_value_comparison
      // TODO: move these to dedicated traits_checker.hh tests
      skipped<
        std::pair<
          const volatile void*[2][4][8][16],
          traits_value_is_equal<unsigned, 2>
        >
      >,
      skipped<
        std::pair<
          std::pmr::vector<double>,
          traits_value_is_greater<unsigned, 100>
        >
      >,
      // multidimensional array of unknown first bound
      std::pair<
        double[][32][16],
        traits_value_is_equal<unsigned, 1>
      >
    >
  >,
  // is_ostreamable
  traits_checker<
    is_ostreamable,
    std::tuple<
      int,
      double,
      char,
      const char*,
      std::string,
      std::pair<std::vector<std::pmr::vector<unsigned>>, std::false_type>,
      std::pair<std::tuple<std::tuple<std::tuple<std::string>>>, std::false_type>,
      std::pair<not_ostreamable_type, std::false_type>,
      ostreamable_type
    >
  >,
  // is_iterable
  traits_checker<
    is_iterable,
    std::tuple<
      std::array<double, 100u>,
      double(&)[1024],
      std::pmr::vector<unsigned>,
      std::pair<double, std::false_type>,
      std::string,
      std::pair<not_ostreamable_type, std::false_type>,
      std::pair<std::tuple<double, int, std::string>, std::false_type>
    >
  >,
  // is_accessible_as<double, T>
  traits_checker<
    partially_fixed<is_accessible_as, double>::type,
    std::tuple<
      std::pair<int, std::false_type>,
      // char, std::byte, or unsigned char are allowed (with cv-qualifiers)
      char,
      unsigned char,
      // signed char is not allowed
      std::pair<signed char, std::false_type>,
      std::byte,
      const char,
      const unsigned char,
      // access as self or cv-qualified self
      double,
      const double,
      std::pair<void*, std::false_type>
    >
  >,
#ifdef INTPTR_MAX
  // is_accesible_as<std::intptr_t, T>
  traits_checker<
    partially_fixed<is_accessible_as, std::intptr_t>::type,
    std::tuple<
      const char,
      std::byte,
      // not type-accessible (not similar) despite same sizeof
      std::pair<void*, std::false_type>,
#ifdef UINTPTR_MAX
      // type-accessible with different sign
      std::uintptr_t,
#endif  // UINTPTR_MAX
      // same with other pointer types
      std::pair<const char*, std::false_type>
    >
  >,
#endif  // INTPTR_MAX
  // is_accessible_as<const int, T>
  traits_checker<
    partially_fixed<is_accessible_as, const int>::type,
    std::tuple<unsigned int, std::pair<short, std::false_type>, char>
  >,
  // is_accessible_as<unsigned char, T>
  traits_checker<
    partially_fixed<is_accessible_as, unsigned char>::type,
    std::tuple<
      // signed char allowed
      signed char,
      const char,
      std::pair<int, std::false_type>,
      const std::byte
    >
  >
>;

}  // namespace testing
}  // namespace npygl

#endif  // NPYGL_TESTING_TYPE_TRAITS_TEST_DRIVER_HH_
